# java基础速记

1. 面向对象和面向过程 
- 面向过程性能比面向对象高，但是没有面向对象易维护、易复用、易扩展
- 面向对象性能比面向过程低，但是它有封装、继承、多态的特性，所以易维护、易复用、易扩展。

2. jvm jdk jre 编译与解释共存
- JVM 是 运行 Java 字节码的虚拟机
- JDK 是 Java Development Kit，它是功能齐全的 Java SDK
- JRE 是 Java Runtime Environment，它是运行时环境

3. 字符型常量和字符串常量
- 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符
- 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
- 内存上: 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)

4. 构造器是否可以被override
- 构造器 不能被 override（重写）,但是可以 overload（重载）

5. 重载和重写
- 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同
- 重写 是子类对父类可访问方法重新编写，方法名、参数必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类

6. 封装继承多态
- 封装 把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，体现一个最少知道原则
- 继承 子类继承父类，通过继承我们能够非常方便地复用以前的代码
- 多态 变量所指向的具体类型在编程时并不确定，而是在程序运行期间才确定，体现一个里氏替换原则

7. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?
- 可变性 String类用final修复char数组，所以不可变；而SB和SB没有final修饰，所以是可变的
- 线程安全 StringBuffer线程安全，StringBuilder不安全
- 性能 少量数据用String，大量数据，单线程用StringBuilder，多线程用StringBuffer

8. 自动装箱与拆箱
- 装箱：将基本类型用它们对应的引用类型包装起来，注意常量池
- 拆箱：将包装类型转换为基本数据类型，注意隐式拆箱

9. 在 Java 中定义一个不做事且没有参数的构造方法的作用
- 执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”

10. import java 和 javax 有什么区别？
- javax 当时只是扩展 API 包来使用，然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分

11. 接口和抽象类的区别是什么？
- 一个类可以实现多个接口，但只能实现一个抽象类
- 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定
- 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符
- 抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范

12. 成员变量与局部变量的区别有哪些？
- 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
- 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
- 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
- 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

13.  静态方法和实例方法有何不同
- 调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式
- 静态方法只能访问类的静态成员变量和静态方法，而能访问实例成员变量和实例方法；实例方法则无此限制

14. == 与 equals
- == : 它的作用是判断两个对象的地址是不是相等
- equals() : 它的作用也是判断两个对象是否相等
    - 类没有覆盖 equals() 方法，等价于“==”
    - 类覆盖了 equals() 方法，比较两个对象的内容是否相等

15. 你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？
- equals 为true，则 hashcode 一定也是相同的
- 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖

16. 为什么 Java 中只有值传递？
- 方法参数是基本类型：执行swap逻辑，操作不影响调用方的值
- 方法参数是引用类型：执行swap逻辑，同样不影响调用方的值

17. final 关键字用在哪3个地方，代表什么
- 变量：不可变。基本类型值不能更改，引用类型不能指向别的对象
- 方法：不可被重写
- 类：不可被继承，方法默认不可被重写

18. Java 序列化中如果有些字段不想进行序列化，怎么办？
- 使用 transient 关键字修饰

19. Java 中 IO 流分为几种?
- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分，可以分为节点流和处理流。

20. 既然有了字节流,为什么还要有字符流?
- 字符到字节的装换耗时，编码容易出错，所以I/O流就提供了一个直接操作字符的接口，方便我们平时对字符进行流操作

21. BIO,NIO,AIO 有什么区别?
- BIO (Blocking I/O): 同步阻塞 I/O 模式，面向流的 I/O 操作方法
- NIO (New I/O): 同步非阻塞的 I/O 模型，面向缓冲，基于通道的 I/O 操作方法
- AIO (Asynchronous I/O): 异步IO，基于事件和回调机制实现的

22. 深拷贝 vs 浅拷贝
- 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝
- 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容

23. Collections 工具类和 Arrays 工具类常见方法
- Collections.syncMap
- Arrays.asList

24. static 关键字主要有以下四种使用场景
- 成员变量和成员方法：被修饰的成员属于类
- 静态代码块：创建多少对象，静态代码块只执行一次，(静态代码块—>非静态代码块—>构造方法)
- 静态内部类：不会隐式持有外部对象的引用

25. this 关键字 super 关键字
- this关键字用于引用类的当前实例
- super关键字用于从子类访问父类的变量和方法
- 在构造器中使用时，this和super都要放在首行

26. 反射机制介绍
- 在运行中，动态获取对象信息以及动态调用对象方法的功能

27. 反射机制优缺点
- 优点： 运行期类型的判断，动态加载类，提高代码灵活度
- 缺点： 1,性能瓶颈：反射相当于一系列解释操作，性能比直接的 java 代码要慢很多。2,安全问题，可以动态改变类的属性，也就表明有安全隐患

28. 反射的应用场景
- 框架设计的灵魂
    - Spring 的 IOC 和 AOP 功能
    - JDBC 通过 Class.forName() 加载数据库驱动